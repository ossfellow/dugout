name: "OCI Image Transformations"
description: "Transform OCI images with metadata enrichment and format conversions"
inputs:
  source-image:
    description: "Source image reference (registry URL or oci directory)"
    required: true
  source-tag:
    description: "Source image tag"
    required: true
  image-title:
    description: "Title of the image (e.g., wasmcloud, wash)"
    required: true
  image-description:
    description: "Description of the image"
    required: false
  image-version:
    description: "Version of the image"
    required: false
  image-authors:
    description: "Authors of the image"
    required: false
  target-registries:
    description: "List of target registries to push to"
    required: false
  image-variants:
    description: "JSON array of image variant configurations [{name, tags[]}]"
    required: false
  default-tags:
    description: "List of tags to apply to base image"
    required: false
  vendor:
    description: "Vendor of the image"
    required: false
    default: "wasmCloud"
  source-repository:
    description: "Source repository of the image"
    required: false
    default: "https://github.com/wasmCloud/wasmCloud"
  show-metadata:
    description: "Whether to print image metadata during transformation"
    required: false
    default: "false"
  registry-credentials:
    description: "JSON array of registry credentials [{url, username, password}]"
    required: false

runs:
  using: "composite"
  steps:
    # Install required tools
    - name: Install tools
      shell: bash
      run: |
        # Install regctl for OCI manipulation
        curl -L https://github.com/regclient/regclient/releases/latest/download/regctl-linux-amd64 -o /usr/local/bin/regctl
        chmod +x /usr/local/bin/regctl

    # Process input image based on source type
    - name: Process OCI input
      shell: bash
      run: |
        mkdir -p workspace
        if [[ "${{ inputs.source-image }}" == oci-archive:* ]]; then
          source_image=${{ inputs.source-image }}
          source_image=${source_image#oci-archive:}
          # Import archive using regctl
          regctl image import \
            ocidir://workspace:${{ inputs.source-tag }} \
            "${source_image}"
        elif [[ "${{ inputs.source-image }}" == ocidir://* ]]; then
          source_image=${{ inputs.source-image }}
          source_image=${source_image#ocidir://}
          # Just copy the directory contents
          cp -r "${source_image}"/* workspace/
        fi

    # Download from registry if not an OCI directory or archive
    - name: Download ${{ inputs.source-image }}:${{ inputs.source-tag }} from registry
      if: ${{ !startsWith(inputs.source-image, 'ocidir://') && !startsWith(inputs.source-image, 'oci-archive://') }}
      shell: bash
      run: |
        # Login to registry if credentials provided
        if [ -n "${{ inputs.registry-credentials }}" ]; then
          echo "${{ inputs.registry-credentials }}" | jq -r '.[] | "\(.url) \(.username) \(.password)"' | while read url username password; do
            echo "Logging in to $url"
            echo "$password" | regctl registry login -u "$username" --pass-stdin "$url"
          done
        fi

        # Strip the oci-archive:// prefix if present
        SOURCE_IMAGE=${{ inputs.source-image }}
        if [[ "${{ inputs.source-image }}" == oci-archive:* ]]; then
          SOURCE_IMAGE=${{ inputs.source-image }}
          SOURCE_IMAGE=${SOURCE_IMAGE#oci-archive:}
        fi

        # Import from OCI archive to workspace
        regctl image import \
          ocidir://workspace:${{ inputs.source-tag }} \
          ${SOURCE_IMAGE}

        # # Download from registry to workspace
        # regctl image copy \
        #   ${{ inputs.source-image }}:${{ inputs.source-tag }} \
        #   ocidir://workspace:${{ inputs.source-tag }} \
        #   --digest-tags \
        #   --referrers

    # Enrich image metadata
    - name: Enrich ${{ inputs.source-image }}:${{ inputs.source-tag }} image metadata
      shell: bash
      run: |
        IMAGE_PATH="${{ startsWith(inputs.source-image, 'ocidir://') && inputs.source-image || 'ocidir://workspace' }}"

        # Process each platform-specific manifest
        for digest in $(regctl image manifest ${IMAGE_PATH}:${{ inputs.source-tag }} -v error | yq -r '.Manifests | with_entries(select(.key | test("Digest"))) | to_entries | .[].value'); do
          echo "Processing manifest $digest"

          # Get current annotations from platform manifest
          CURRENT_ANNOTATIONS=$(regctl blob get ${IMAGE_PATH}:${{ inputs.source-tag }} ${digest} -v error | yq -r '.annotations // {}')
          echo "CURRENT_ANNOTATIONS: $CURRENT_ANNOTATIONS"

          # Build annotation arguments
          ANNOTATION_ARGS=""

          # Required annotations
          if ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.created"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.created=$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          fi

          if ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.title"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.title=${{ inputs.image-title }}"
          fi

          # Optional annotations
          if [ -n "${{ inputs.image-authors }}" ] && ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.authors"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.authors=${{ inputs.image-authors }}"
          fi

          if [ -n "${{ inputs.vendor }}" ] && ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.vendor"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.vendor=${{ inputs.vendor }}"
          fi

          if [ -n "${{ inputs.source-repository }}" ] && ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.source"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.source=${{ inputs.source-repository }}"
          fi

          if [ -n "${{ inputs.image-description }}" ] && ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.description"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.description=${{ inputs.image-description }}"
          fi

          if [ -n "${{ inputs.image-version }}" ] && ! echo "$CURRENT_ANNOTATIONS" | jq -e '.["org.opencontainers.image.version"]' >/dev/null; then
            ANNOTATION_ARGS="$ANNOTATION_ARGS --annotation=[*]org.opencontainers.image.version=${{ inputs.image-version }}"
          fi
          echo "ANNOTATION_ARGS: $ANNOTATION_ARGS"

          # Always run regctl for OCI conversion, add annotations if any
          regctl image mod \
            ${IMAGE_PATH}@${{ inputs.source-tag }} \
            --replace \
            --to-oci \
            --to-oci-referrers \
            --label-to-annotation \
            "${ANNOTATION_ARGS}"
        done

    # Show image metadata if requested
    - name: Show ${{ inputs.source-image }}:${{ inputs.source-tag }} image enriched metadata
      if: inputs.show-metadata == 'true'
      shell: bash
      run: |
        IMAGE_PATH="${{ startsWith(inputs.source-image, 'ocidir://') && inputs.source-image || 'ocidir://workspace' }}"

        echo "=== OCI Image Index (Multi-platform Manifest) ==="
        regctl image manifest ${IMAGE_PATH}:${{ inputs.source-tag }} -v error | yq -P
        echo

        echo "=== Processing Individual Manifests ==="
        for digest in $(regctl image manifest ${IMAGE_PATH}:${{ inputs.source-tag }} -v error | yq -r '.Manifests | with_entries(select(.key | test("Digest"))) | to_entries | .[].value'); do
          echo "=== Manifest for $digest ==="
          regctl blob get ${IMAGE_PATH}:${{ inputs.source-tag }} ${digest} -v error | yq -P
          echo

          config_digest=$(regctl blob get ${IMAGE_PATH}:${{ inputs.source-tag }} ${digest} -v error | yq -r '.config.digest')
          echo "=== Config for $config_digest ==="
          regctl blob get ${IMAGE_PATH}:${{ inputs.source-tag }} ${config_digest} -v error | yq -P
          echo
        done

    # Push to target registries
    - name: Push to target registries
      if: inputs.target-registries
      shell: bash
      run: |
        IMAGE_PATH="${{ startsWith(inputs.source-image, 'ocidir://') && inputs.source-image || 'ocidir://workspace' }}"

        # Login to registries if credentials provided
        if [ ! -z "${{ inputs.registry-credentials }}" ]; then
          echo "${{ inputs.registry-credentials }}" | jq -r '.[] | "\(.url) \(.username) \(.password)"' | while read url username password; do
            # Handle different registry types
            case "$url" in
              "docker.io"|"registry-1.docker.io")
                # Docker Hub needs no URL for login
                echo "$password" | regctl registry login -u "$username" --pass-stdin
                ;;
              *.azurecr.io)
                # Azure Container Registry
                echo "$password" | regctl registry login -u "$username" --pass-stdin "$url"
                ;;
              *)
                # GitHub Container Registry and others
                echo "$password" | regctl registry login -u "$username" --pass-stdin "$url"
                ;;
            esac
          done
        fi

        # Push each variant to each registry with each tag
        echo "${{ inputs.target-registries }}" | while read registry; do
          if [ ! -z "$registry" ]; then
            # Base image
            regctl image copy \
              ${IMAGE_PATH}:${{ inputs.source-tag }} \
              ${registry}/${{ inputs.source-image }}:${{ inputs.source-tag }} \
              --digest-tags \
              --referrers

            # Variants if specified
            if [ ! -z "${{ inputs.image-variants }}" ]; then
              echo "${{ inputs.image-variants }}" | jq -c '.[]' | while read -r variant; do
                name=$(echo $variant | jq -r '.name')
                echo $variant | jq -r '.tags[]' | while read -r tag; do
                  regctl image copy \
                    ${IMAGE_PATH}:${{ inputs.source-tag }} \
                    ${registry}/${{ inputs.source-image }}:${tag} \
                    --digest-tags \
                    --referrers
                done
              done
            fi

            # Additional tags if specified
            if [ ! -z "${{ inputs.default-tags }}" ]; then
              echo "${{ inputs.default-tags }}" | while read tag; do
                if [ ! -z "$tag" ]; then
                  regctl image copy \
                    ${IMAGE_PATH}:${{ inputs.source-tag }} \
                    ${registry}/${{ inputs.source-image }}:${tag} \
                    --digest-tags \
                    --referrers
                fi
              done
            fi
          fi
        done
